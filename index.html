<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
<title>作業ペース計測</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#0a2a66">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="apple-touch-icon" href="icons/icon-192.png">

<style>
:root{
  --bg:#0a2a66;
  --fg:#ffffff;
  --muted:rgba(255,255,255,.8);
  --line:rgba(255,255,255,.55);
  --btn-bg:#ffffff;
  --btn-fg:#0a2a66;
}
*{ box-sizing:border-box; }
body{
  margin:0;
  background:var(--bg);
  color:var(--fg);
  font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,"Hiragino Sans","Noto Sans JP",sans-serif;
}
.wrap{
  min-height:100vh;
  padding:max(16px, env(safe-area-inset-top)) 12px max(16px, env(safe-area-inset-bottom));
  display:flex;
  flex-direction:column;
  gap:16px;
}
.big-label{
  font-size:clamp(20px,5vw,28px);
  font-weight:500;
  color:var(--muted);
}
.big-time{
  font-size:clamp(48px,14vw,68px);
  font-weight:900;
  line-height:1.08;
  white-space:nowrap;
  font-variant-numeric:tabular-nums;
}
.divider{
  height:2px;
  background:var(--line);
  width:100%;
  margin-top:6px;
}
.field{
  display:flex;
  flex-direction:column;
  gap:6px;
}
.label{
  font-size:clamp(17px,4.5vw,26px);
  font-weight:500;
  color:var(--muted);
  white-space:nowrap;
}
.value{
  width:100%;
  text-align:right;
  font-size:clamp(28px,7vw,40px);
  font-weight:800;
  color:var(--fg);
  background:transparent;
  border:none;
  border-bottom:2px solid var(--line);
  padding-bottom:4px;
  outline:none;
}
.section-title{
  font-size:clamp(22px,5.5vw,32px);
  font-weight:600;
  color:var(--muted);
}
.eta{
  font-size:clamp(52px,15vw,84px);
  font-weight:900;
  line-height:1;
  white-space:nowrap;
  font-variant-numeric:tabular-nums;
}

/* Wake Lock */
.wake-line{
  display:flex;
  align-items:center;
  gap:10px;
  margin-top:10px;
  color:var(--muted);
  font-size:clamp(14px,3.8vw,18px);
  white-space:nowrap;
}
.wake-btn{
  border:none;
  border-radius:999px;
  padding:10px 18px;
  font-weight:900;
  background:#fff;
  color:var(--btn-fg);
  min-width:92px;
}
.wake-btn.on{ background:#fff; }
.wake-msg{ opacity:.8; }

/* Buttons */
.btns{
  display:flex;
  gap:12px;
}
button.action{
  flex:1;
  border:none;
  border-radius:16px;
  padding:16px 0;
  font-size:clamp(18px,5vw,28px);
  font-weight:800;
  background:#fff;
  color:var(--btn-fg);
}
button.action:disabled{ opacity:.6; }

/* Log */
.log-title{
  color:var(--muted);
  font-size:clamp(14px,3.8vw,18px);
  font-weight:600;
}
.log-box{
  margin-top:6px;
  border:2px solid rgba(255,255,255,.35);
  border-radius:14px;
  padding:10px 12px;
  color:rgba(255,255,255,.92);
  font-size:clamp(12px,3.3vw,15px);
  line-height:1.45;
  font-variant-numeric:tabular-nums;
  white-space:pre-line;
  user-select:text;

  max-height:28vh;
  overflow-y:auto;
  -webkit-overflow-scrolling:touch;
}
.log-empty{ opacity:.8; }
</style>
</head>

<body>
<div class="wrap">

  <div>
    <div class="big-label">所要時間</div>
    <div id="elapsed" class="big-time">00:00:00</div>
    <div class="divider"></div>
  </div>

  <div class="field">
    <div class="label">ロット数（1ロットあたりの個数）</div>
    <input id="lotCount" class="value" type="number" min="1" value="20" inputmode="numeric">
  </div>
  <div class="divider"></div>

  <div class="field">
    <div class="label">本日のノルマ（合計個数）</div>
    <input id="targetCount" class="value" type="number" min="1" value="1000" inputmode="numeric">
  </div>
  <div class="divider"></div>

  <div>
    <div class="section-title">予測完了時間</div>
    <div id="pred" class="eta">00:00:00</div>

    <div class="wake-line">
      画面ON維持：
      <button id="wakeBtn" class="wake-btn" type="button">OFF</button>
      <span id="wakeMsg" class="wake-msg"></span>
    </div>

    <div class="divider"></div>
  </div>

  <div class="btns">
    <button id="startBtn" class="action">スタート</button>
    <button id="stopBtn"  class="action" disabled>ストップ</button>
    <button id="resetBtn" class="action">リセット</button>
  </div>

  <div class="divider"></div>

  <div>
    <div class="log-title">ログ</div>
    <div id="logBox" class="log-box log-empty">（まだありません）</div>
  </div>

</div>

<script>
(() => {
  const STORE_KEY = "work_pace_state_v5";

  // ---- Timer state ----
  let running = false;
  let startMs = 0;
  let elapsedMs = 0;
  let timer = null;

  // ---- Log segments ----
  let segmentStartMs = null;
  let segments = []; // [{start:number, end:number|null}]

  // ---- DOM ----
  const elapsedEl = document.getElementById('elapsed');
  const predEl = document.getElementById('pred');
  const lotEl = document.getElementById('lotCount');
  const targetEl = document.getElementById('targetCount');
  const startBtn = document.getElementById('startBtn');
  const stopBtn  = document.getElementById('stopBtn');
  const resetBtn = document.getElementById('resetBtn');
  const logBox = document.getElementById('logBox');

  const wakeBtn = document.getElementById('wakeBtn');
  const wakeMsg = document.getElementById('wakeMsg');

  const pad = (n) => String(n).padStart(2,'0');

  function fmtHMS(ms){
    const s = Math.floor(ms/1000);
    const hh = Math.floor(s/3600);
    const mm = Math.floor(s/60) % 60;
    const ss = s % 60;
    return `${pad(hh)}:${pad(mm)}:${pad(ss)}`;
  }

  // ★ MM/DD_HH:MM:SS
  function fmtStamp(ts){
    const d = new Date(ts);
    return `${pad(d.getMonth()+1)}/${pad(d.getDate())}_${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
  }

  // ★ 〜区切り + (所要時間) 付き
  function fmtSegment(seg){
    const s = fmtStamp(seg.start);

    if (seg.end == null){
      return `${s} 〜 …（計測中）`;
    }

    const e = fmtStamp(seg.end);
    const dur = fmtHMS(seg.end - seg.start);
    return `${s} 〜 ${e}　(${dur})`;
  }

  function currentElapsedMs(){
    return running ? (elapsedMs + (Date.now() - startMs)) : elapsedMs;
  }

  function toPosInt(v, fallback){
    const n = Number(v);
    if (!Number.isFinite(n)) return fallback;
    const i = Math.floor(n);
    return i > 0 ? i : fallback;
  }

  function setButtons(){
    startBtn.disabled = running;
    stopBtn.disabled = !running;
  }

  function renderLog(){
    if (!segments.length){
      logBox.textContent = "（まだありません）";
      logBox.classList.add("log-empty");
      return;
    }
    logBox.textContent = segments.map(fmtSegment).join("\n");
    logBox.classList.remove("log-empty");
  }

  function render(){
    const cur = currentElapsedMs();
    elapsedEl.textContent = fmtHMS(cur);

    const lot = Math.max(1, toPosInt(lotEl.value, 1));
    const tgt = Math.max(0, toPosInt(targetEl.value, 0));
    const predictedMs = Math.ceil(cur * tgt / lot); // ceil(経過時間×ノルマ÷ロット数)
    predEl.textContent = fmtHMS(predictedMs);

    renderLog();
  }

  // ---- Persistence ----
  let lastSaveAt = 0;
  function saveState(force=false){
    const now = Date.now();
    if (!force && (now - lastSaveAt) < 800) return;
    lastSaveAt = now;

    const state = {
      lot: toPosInt(lotEl.value, 1),
      target: toPosInt(targetEl.value, 1),
      elapsedMs: currentElapsedMs(),
      running,
      savedAt: now,
      segmentStartMs,
      segments,
      wakeEnabled
    };
    try{ localStorage.setItem(STORE_KEY, JSON.stringify(state)); }catch(e){}
  }

  function loadState(){
    try{
      const raw = localStorage.getItem(STORE_KEY);
      if (!raw) return;
      const s = JSON.parse(raw);
      if (!s || typeof s !== "object") return;

      if (Number.isFinite(Number(s.lot)) && Number(s.lot) > 0) lotEl.value = String(Math.floor(Number(s.lot)));
      if (Number.isFinite(Number(s.target)) && Number(s.target) > 0) targetEl.value = String(Math.floor(Number(s.target)));

      elapsedMs = (Number.isFinite(Number(s.elapsedMs)) && Number(s.elapsedMs) >= 0) ? Math.floor(Number(s.elapsedMs)) : 0;

      segments = Array.isArray(s.segments) ? s.segments
        .filter(x => x && Number.isFinite(Number(x.start)))
        .map(x => ({
          start: Math.floor(Number(x.start)),
          end: (x.end == null ? null : (Number.isFinite(Number(x.end)) ? Math.floor(Number(x.end)) : null))
        }))
        : [];

      wakeEnabled = (s.wakeEnabled === true);

      if (s.running === true && Number.isFinite(Number(s.savedAt))) {
        const delta = Math.max(0, Date.now() - Number(s.savedAt));
        elapsedMs += delta;

        running = true;
        startMs = Date.now();

        segmentStartMs = Number.isFinite(Number(s.segmentStartMs)) ? Math.floor(Number(s.segmentStartMs)) : null;

        const last = segments.length ? segments[segments.length - 1] : null;
        const lastIsRunning = !!(last && last.end == null);

        if (segmentStartMs) {
          if (!lastIsRunning) segments.push({ start: segmentStartMs, end: null });
        } else {
          segmentStartMs = Date.now();
          if (!lastIsRunning) segments.push({ start: segmentStartMs, end: null });
        }
      } else {
        running = false;
        segmentStartMs = null;
      }
    }catch(e){}
  }

  // ---- Actions ----
  function start(){
    if (running) return;

    running = true;
    startMs = Date.now();

    segmentStartMs = Date.now();
    const last = segments.length ? segments[segments.length - 1] : null;
    if (!(last && last.end == null)) {
      segments.push({ start: segmentStartMs, end: null });
    } else {
      segmentStartMs = last.start;
    }

    setButtons();
    timer = setInterval(() => { render(); saveState(false); }, 200);
    render();
    saveState(true);
  }

  function stop(){
    if (!running) return;

    elapsedMs = currentElapsedMs();

    const last = segments.length ? segments[segments.length - 1] : null;
    if (last && last.end == null) last.end = Date.now();

    running = false;
    segmentStartMs = null;

    if (timer) clearInterval(timer);
    timer = null;

    setButtons();
    render();
    saveState(true);
  }

  function reset(){
    running = false;
    if (timer) clearInterval(timer);
    timer = null;

    elapsedMs = 0;
    startMs = 0;
    segmentStartMs = null;
    segments = []; // ★ログも消す

    setButtons();
    render();
    saveState(true);
  }

  // ---- Hook inputs ----
  lotEl.oninput = () => { saveState(true); render(); };
  targetEl.oninput = () => { saveState(true); render(); };

  startBtn.onclick = start;
  stopBtn.onclick = stop;
  resetBtn.onclick = reset;

  window.addEventListener('pagehide', () => saveState(true));
  window.addEventListener('beforeunload', () => saveState(true));
  document.addEventListener('visibilitychange', () => {
    if (document.visibilityState === 'hidden') saveState(true);
  });

  // ===== Wake Lock =====
  let wakeSupported = ('wakeLock' in navigator);
  let wakeEnabled = false;
  let wakeLockSentinel = null;

  function setWakeUI(){
    wakeBtn.textContent = wakeEnabled ? "ON" : "OFF";
    wakeBtn.classList.toggle("on", wakeEnabled);
    if (!wakeSupported) {
      wakeMsg.textContent = "（未対応）";
      wakeBtn.disabled = true;
    } else {
      wakeBtn.disabled = false;
    }
  }

  async function requestWakeLock(){
    if (!wakeSupported) return false;
    try{
      wakeLockSentinel = await navigator.wakeLock.request('screen');
      wakeLockSentinel.addEventListener('release', () => {
        wakeLockSentinel = null;
        wakeEnabled = false;
        setWakeUI();
        wakeMsg.textContent = "（解除）";
        saveState(true);
      });
      wakeMsg.textContent = "";
      return true;
    }catch(e){
      wakeLockSentinel = null;
      wakeEnabled = false;
      setWakeUI();
      wakeMsg.textContent = "（ON不可）";
      saveState(true);
      return false;
    }
  }

  async function releaseWakeLock(){
    try{
      if (wakeLockSentinel) await wakeLockSentinel.release();
    }catch(e){}finally{
      wakeLockSentinel = null;
      wakeEnabled = false;
      setWakeUI();
      wakeMsg.textContent = "";
      saveState(true);
    }
  }

  wakeBtn.onclick = async () => {
    if (!wakeSupported) return;
    if (!wakeEnabled) {
      wakeEnabled = true;
      setWakeUI();
      await requestWakeLock();
    } else {
      await releaseWakeLock();
    }
  };

  document.addEventListener('visibilitychange', async () => {
    if (!wakeSupported) return;
    if (document.visibilityState === 'hidden') {
      if (wakeLockSentinel) {
        try{ await wakeLockSentinel.release(); }catch(e){}
        wakeLockSentinel = null;
      }
    } else {
      if (wakeEnabled && !wakeLockSentinel) {
        await requestWakeLock();
      }
    }
  });

  // ---- Init ----
  loadState();
  setButtons();
  setWakeUI();
  render();

  if (wakeEnabled) requestWakeLock();

  if (running) {
    timer = setInterval(() => { render(); saveState(false); }, 200);
  }

  saveState(true);
})();
</script>

<script>
  // Service Worker
  if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
      navigator.serviceWorker.register('./sw.js');
    });
  }
</script>

</body>
</html>